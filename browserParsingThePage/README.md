# 问题：浏览器从输入URL到看到页面发生了什么？

# 解答：

**简单回答：**
* DNS解析：将域名解析成IP地址
* 发起TCP连接：TCP三次握手
* 发送HTTP请求
* 服务器处理请求并返回HTTP报文
* 浏览器解析渲染页面
* 连接结束：TCP四次挥手

## 一、DNS解析
DNS 解析简单来说就是 URL 网址转换成对应的 IP 地址的过程。下面先了解一些基础概念：

### 什么是 IP 地址？
IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，
它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址不好记忆，所以诞生了 URL 地址。

#### 分支问题：如何分辨IP是公网IP还是内网IP？
以下是常见的内网IP地址：
1. 10.0.0.0 到 10.255.255.255
2. 172.16.0.0 到172.31.255.255
3. 192.168.0.0 到192.168.255.255

### 什么是 URL？
URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。

```
scheme: // host.domain:port / path / filename ? abc = 123 # 456789
```

```
scheme       - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。
host         - 定义域主机（http 的默认主机是 www）
domain       - 定义因特网域名，比如 google.com
port         - 定义主机上的端口号（http 的默认端口号是 80）
path         - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。
filename     - 定义文档/资源的名称
query        - 即查询参数
fragment     - 即 # 后的hash值，一般用来定位到某个位置
```

### 什么是 DNS？
DNS 就是域名系统，全称是 **D**omain **N**ame **S**ystem，是一个统称的概念。

DNS 如何知道 URL 地址的对应 IP 地址呢？早期通过我们电脑上的hosts文件查找，随着互联网的设备越来越多，hosts已经不足以支撑那么多，需要一台 DNS 服务器帮助我们解析转换。

常见的DNS服务器商：
* OpenDNS
* Google DNS
* DNSPOD

浏览器输入地址到DNS服务器解析，并非一步到位，还存在一个查找的过程：浏览器缓存 → 系统缓存 → hosts → 路由器缓存→ ISP DNS 缓存 → 递归搜索。

![](https://7675-vuepress-7g6mefe5ad729c51-1258812673.tcb.qcloud.la/Image/2022/FrontEnd-Replay/Network/browserParsingThePage/dns1.png?sign=e9d2415389349493687e65de98ff2ff8&t=1641891162)

如下，展示了一个可能的详细过程（Chrome浏览器）：
| 步骤名称 | 步骤描述 |
| ------- | -------- |
| 浏览器缓存 | 首先搜索浏览器的DNS缓存，看自身的缓存中是否有对应的条目，如果有且没有过期则解析到此结束。(缓存时间比较短，TTL默认是1000，且只能容纳1000条缓存)</br></br>注：查看浏览器的DNS缓存，可以使用 chrome://net-internals/#dns 来进行查看。（无效） |
| 系统缓存 | 如果浏览器缓存里没有找到需要的记录，浏览器会调用系统缓存里的记录。如果有则解析成功。</br></br>注：查看操作系统的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看。 |
| hosts文件 | 如果在系统的DNS缓存也没有找到，那么尝试读取hosts文件，看看这里面有没有该域名对应的IP地址，如果有则解析成功。</br></br> 注：Windows上hosts文件位置，C:\Windows\System32\drivers\etc。 |
| 路由器缓存 | 如果还是没有找到需要的缓存，将前面的查询请求发给路由器，它一般会有自己的DNS缓存。如果有则解析成功。 |
| ISP DNS 缓存 | 如果还是没有，浏览器就会发起一个DNS的系统调用，向本地配置的首选DNS服务器发起域名解析请求。运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。</br></br>注：每一个ISP（网络服务提供商），或一个大学，甚至是一个大学里的系都会有一个自己的本地域名服务器，他会在url第一次访问时缓存该域名的指向。下次再访问时，他会从缓存里把这个url曾经指向的IP调出来 |
| 递归搜索 | 如果没有需要的缓存，你的ISP的DNS服务器会代替我们的浏览器发起迭代DNS解析请求，从根域名开始进行递归查询。</br></br>递归查询：主机向本地域名服务器的查询一般都是采用递归查询。如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果可能是所要查询的IP地址，也可能是一个失败的响应，表示无法查询到所需的IP地址。</br></br>迭代查询：本地域名服务器向根域名服务器的查询通常是采用迭代查询。当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么返回给本地域名服务器所要查询的IP地址，要么返回给本地域名服务器下一步应当查询的域名服务器的IP地址。 |

如果经过以上的步骤，还没有解析成功，那么会进行如下步骤：
| 步骤名称 | 步骤描述 |
| ------- | -------- |
| NetBIOS名称缓存 | 操作系统就会查找 NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。 |
| WINS 服务器 | 如果还没成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器） |
| 广播查找 | 如果还没成功，那么客户端就要进行广播查找 |
| LMHOSTS文件 | 那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样） |
| <font color="#ff0000">解析失败</font> | 只要前面的这些步骤中有一步可以解析成功，那就可以成功和目标计算机进行通信。但是如果还没有解析成功，那么这次解析失败，那就无法跟目标计算机进行通信。 |

### DNS的优化与应用
1. **DNS缓存：** DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</br></br>
2. **DNS负载均衡(DNS重定向)：** DNS负载均衡技术的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时， DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问 引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。</br></br>
3. 大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。</br></br>
4. **dns-prefetch：** DNS Prefetch 是一种 DNS 预解析技术。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。

## 二、发起TCP连接
User-Agent（chrome浏览器）上访问url，通过dns解析拿到ip后，会以一个随机端口（1024 < 端口 < 65535）向服务器的WEB程序（常用的有tomcat、nginx等）80端口发起TCP的连接请求。

这个连接请求（原始的http请求经过TCP/IP4层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。

### TCP三次握手
![](https://7675-vuepress-7g6mefe5ad729c51-1258812673.tcb.qcloud.la/Image/2022/FrontEnd-Replay/Network/browserParsingThePage/tcp1.png?sign=1e178678860939e05234f5f09a9b4dac&t=1641891156)

1. 客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口（第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。）

2. 服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息（第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。）

3. 客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。）

#### 2.1 什么是半连接队列？
服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。

当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

这里在补充一点关于SYN-ACK 重传次数的问题：
服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。
注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s......

#### 2.2 ISN(Initial Sequence Number)是固定的吗？
当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。
三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

#### 2.4 三次握手过程中可以携带数据吗？
其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据
为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。
也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。

##### 2.4 SYN攻击是什么？
服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。
检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

```shell
netstat -n -p TCP | grep SYN_RECV
```

常见的防御 SYN 攻击的方法有如下几种：
* 缩短超时（SYN Timeout）时间
* 增加最大半连接数
* 过滤网关防护
* SYN cookies技术

### TCP状态：

* LISTEN： 侦听来自远方TCP端口的连接请求；
* SYN-SENT：在发送连接请求后等待匹配的连接请求；
* SYN-RECEIVED： 在收到和发送一个连接请求后等待对连接请求的确认；
* ESTABLISHED： 代表一个打开的连接，数据可以传送给用户；
* FIN-WAIT-1： 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；
* FIN-WAIT-2： 从远程TCP等待连接中断请求；
* CLOSE-WAIT： 等待从本地用户发来的连接中断请求；
* CLOSING：等待远程TCP对连接中断的确认；
* LAST-ACK： 等待原来发向远程TCP的连接中断请求的确认；
* TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认；
* CLOSED： 没有任何连接状态；

## 三、发送HTTP请求
> 首先科补一个小知识，HTTP的端口为80/8080，而HTTPS的端口为443

发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口 请求报文由**请求行**，**请求抱头**，**请求正文**组成。

### 请求行
请求行的格式为```Method Request-URL HTTP-Version CRLF```

eg: ```GET index.html HTTP/1.1``` 

常用的方法有: 
* GET
* POST
* PUT
* DELETE
* OPTIONS
* HEAD

#### GET和POST的区别
* GET在浏览器回退时是无害的，而POST会再次提交请求。
* GET产生的URL地址可以被Bookmark，而POST不可以。
* GET请求会被浏览器主动cache，而POST不会，除非手动设置。
* GET请求只能进行url编码，而POST支持多种编码方式。
* GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
* GET请求在URL中传送的参数是有长度限制的，而POST么有。
* 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
* GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
* GET参数通过URL传递，POST放在Request body中。
* GET会产生一个TCP数据包，而POST会产生两个TCP数据包。
    * 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);
    * 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。Firefox只会发送一次。

以上是网上常见的标准答案。还有不同的见解：GET和POST本质上都是TCP链接，但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。而且不同的浏览器和服务器，对GET的限制还不一致。

### 请求报头
请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。Chrome浏览器打开F12 > Network > 选择一个请求 > Headers > Request Headers 就能够看到常见的请求头。

### 请求正文
当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。Chrome浏览器打开F12 > Network > 选择一个请求 > Payload > Request Payload

### 更重要的事情-HTTP缓存
HTTP属于客户端缓存，我们常认为浏览器有一个缓存数据库，用来保存一些静态文件，下面我们分为以下几个方面来简单介绍HTTP缓存

#### 缓存的规则
缓存规则分为**强制缓存**和**协商缓存**

#### 强制缓存
当缓存数据库中有客户端需要的数据，客户端直接将数据从其中拿出来使用（如果数据未失效），当缓存服务器没有需要的数据时，客户端才会向服务端请求。
![](https://7675-vuepress-7g6mefe5ad729c51-1258812673.tcb.qcloud.la/Image/2022/FrontEnd-Replay/Network/browserParsingThePage/cache1.png?sign=ecb64f4e6aecec53893bc822fb0693f4&t=1642058833)

#### 协商缓存
又称对比缓存。客户端会先从缓存数据库拿到一个缓存的标识，然后向服务端验证标识是否失效，如果没有失效服务端会返回304，这样客户端可以直接去缓存数据库拿出数据，如果失效，服务端会返回新的数据
![](https://7675-vuepress-7g6mefe5ad729c51-1258812673.tcb.qcloud.la/Image/2022/FrontEnd-Replay/Network/browserParsingThePage/cache2.png?sign=1c004148534bc5517e9e94e6829d1548&t=1642058876)

> 强制缓存的优先级高于协商缓存，若两种缓存皆存在，且强制缓存命中目标，则协商缓存不再验证标识。

#### 缓存的方案
上面的内容让我们大概了解了缓存机制是怎样运行的，但是，服务器是如何判断缓存是否失效呢？我们知道浏览器和服务器进行交互的时候会发送一些请求数据和响应数据，我们称之为HTTP报文。报文中包含首部header和主体部分body。与缓存相关的规则信息就包含在header中。boby中的内容是HTTP请求真正要传输的部分。举个HTTP报文header部分的例子如下：

**强制缓存：**
对于强制缓存，服务器响应的header中会用两个字段来表明——Expires和Cache-Control。

**Expires**
Exprires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差，另一方面，Expires是HTTP1.0的产物，故现在大多数使用Cache-Control替代。

**Cache-Control**
Cache-Control有很多属性，不同的属性代表的意义也不同。
* private：客户端可以缓存
* public：客户端和代理服务器都可以缓存
* max-age=t：缓存内容将在t秒后失效
* no-cache：需要使用协商缓存来验证缓存数据
* no-store：所有内容都不会缓存。

**协商缓存：**
对于协商缓存来说，缓存标识我们需要着重理解一下，下面我们将着重介绍它的两种缓存方案。

**Last-Modified**
* if-Modified-Since:浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可。
* 从字面上看，就是说：从某个时间节点算起，是否文件被修改了
* 如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK
* 如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified
* if-Unmodified-Since:从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改
  * 如果没有被修改:则开始'继续'传送文件: 服务器返回: 200 OK
  * 如果文件被修改:则不传输,服务器返回: 412 Precondition failed (预处理错误)

> Last-Modified：服务器在响应请求时，会告诉浏览器资源的最后修改时间。

Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1推出了Etag。

**Etag**
> Etag：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）

* If-None-Match：再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比。
  * 不同，说明资源被改动过，则响应整个资源内容，返回状态码200。
  * 相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304.

但是实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用Etag了。

**缓存的优点**
* 减少了冗余的数据传递，节省宽带流量
* 减少了服务器的负担，大大提高了网站性能
* 加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因。

#### 不同刷新的请求执行过程
* **浏览器地址栏中写入URL，回车：** 浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）
* **F5刷新：** 就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就战战兢兢的发送一个请求带上If-Modify-since。
* **Ctrl+F5：** 告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作.

## 四、服务器处理请求并返回HTTP报文
它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，我使用过的Web服务器有Tomcat, Nginx和Apache等等
HTTP报文也分成三份：

### 状态码
状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:

* 1xx：指示信息–表示请求已接收，继续处理。
* 2xx：成功–表示请求已被成功接收、理解、接受。
* 3xx：重定向–要完成请求必须进行更进一步的操作。
* 4xx：客户端错误–请求有语法错误或请求无法实现。
* 5xx：服务器端错误–服务器未能实现合法的请求。

**常见状态码区别**
* 200 成功：请求成功，通常服务器提供了需要的资源。
* 204 无内容：服务器成功处理了请求，但没有返回任何内容。
* 301 永久移动：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
* 302 临时移动：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
* 304 未修改：自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
* 400 错误请求：服务器不理解请求的语法。
* 401 未授权：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
* 403 禁止：服务器拒绝请求。
* 404 未找到：服务器找不到请求的网页。
* 422 无法处理：请求格式正确，但是由于含有语义错误，无法响应
* 500 服务器内部错误：服务器遇到错误，无法完成请求。


### 响应报头
常见的响应报头字段有: Server, Connection...。

### 响应报文
你从服务器请求的HTML,CSS,JS文件就放在这里面

## 五、浏览器解析渲染页面
浏览器解析渲染页面的过程：
* 解析HTML形成DOM树
* 解析CSS形成CSSOM 树
* 合并DOM树和CSSOM树形成渲染树
* 浏览器开始渲染并绘制页面

这个过程涉及两个比较重要的概念：
* 回流：DOM节点都是以盒模型形式存在，需要浏览器去计算位置和宽度等，这个过程就是回流。
* 重绘：等到页面的宽高，大小，颜色等属性确定下来后，浏览器开始绘制内容，这个过程叫做重绘。



### 回流重绘
当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。

会导致回流的操作：
* 页面首次渲染
* 浏览器窗口大小发生改变
* 元素尺寸或位置发生改变
* 元素内容变化（文字数量或图片大小等等）
* 元素字体大小变化
* 添加或者删除可见的DOM元素
* 激活CSS伪类（例如：:hover）
* 查询某些属性或调用某些方法

一些常用且会导致回流的属性和方法：
* ```clientWidth、clientHeight、clientTop、clientLeft```
* ```offsetWidth、offsetHeight、offsetTop、offsetLeft```
* ```scrollWidth、scrollHeight、scrollTop、scrollLeft```
* ```scrollIntoView()、scrollIntoViewIfNeeded()```
* ```getComputedStyle()```
* ```getBoundingClientRect()```
* ```scrollTo()```


当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

### 优化
#### CSS
* 避免使用table布局。
* 尽可能在DOM树的最末端改变class。
* 避免设置多层内联样式。
* 将动画效果应用到position属性为absolute或fixed的元素上。
* 避免使用CSS表达式（例如：calc()）。

#### JavaScript
* 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。
* 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。
* 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
* 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
* 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

#### JS的解析
JS的解析是由浏览器的JS引擎完成的。由于JavaScript是单线程运行，也就是说一个时间只能干一件事，干这件事情时其他事情都有排队，但是有些人物比较耗时（例如IO操作），所以将任务分为同步任务和异步任务，所有的同步任务放在主线程上执行，形成执行栈，而异步任务等待，当执行栈被清空时才去看看异步任务有没有东西要搞，有再提取到主线程执行，这样往复循环（冤冤相报何时了，阿弥陀佛），就形成了Event Loop事件循环，下面来看看大人物


#### Event Loop
JavaScript是一门单线程语言，尽管H5中提出了Web-Worker，能够模拟实现多线程，但本质上还是单线程。单线程就像排队只排一列，为了提升速度浏览器的JS引擎处理JavaScript时分为同步任务和异步任务


先看一段代码
```javascript
setTimeout(function(){
    console.log('定时器开始啦')
});

new Promise(function(resolve){
    console.log('马上执行for循环啦');
    for(var i = 0; i < 10000; i++){
        i == 99 && resolve();
    }
}).then(function(){
    console.log('执行then函数啦')
});

console.log('代码执行结束');
```


## 六、连接结束

### TCP四次挥手
建立一个连接需要三次握手，而终止一个连接要经过四次挥手。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力

TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。

刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：

1. 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。
即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。
1. 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。
即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
1. 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。
1. 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。
即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。

在socket编程中，任何一方执行close()操作即可产生挥手操作。



**参考：**
1. [史上最详细的经典面试题 从输入URL到看到页面发生了什么？](https://juejin.cn/post/6844903832435032072#comment)
1. [从URL输入到页面展现到底发生什么？](https://juejin.cn/post/6844903784229896199)
1. [字节面试被虐后，是时候搞懂 DNS 了](https://juejin.cn/post/6990344840181940261#heading-0)
1. [DNS域名解析的过程](https://www.yuque.com/gdnnth/fe-optimise/ogdd8t)
1. [DNS是干什么的？修改hosts的原理又是什么？](https://www.bilibili.com/video/BV1Yx411p7KD?from=search&seid=4297856666634992476&spm_id_from=333.337.0.0)
1. [面试官，不要再问我三次握手和四次挥手](https://juejin.cn/post/6844903958624878606)
1. [GET和POST有什么区别？及为什么网上的多数答案都是错的。](https://juejin.cn/post/6844903508370538503)